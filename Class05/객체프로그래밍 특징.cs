using System;

namespace Class05
{
    class 객체프로그래밍_특징
    {
        // Object Oriented Programing 객체 지향 프로그래밍
        #region 추상화
        // 1. 추상화 
        // 모든 사물을 구체적으로는 표현하기 힘들기 때문에 추상적으로 사물을 표현하여
        // 그 사물의 특징을 객체화시킨 것
        // class 
        // 사용자정의타입 이름 = new 사용자정의타입();
        // 속성과 기능 

        // 유니티 게임에서 클래스를 만들고 싶은대
        // 처음에 어떤 클래스를 만들어야 할지 모르는 경우가 있다.
        // 만들고 싶은 내용을 적어두고(생각을 하고) 그것을 바로 클래스로 만든다.
        // 몬스터 클래스를 생성하였다. 
        #endregion
        class Monster 
        {
            // 몬스터가 가지고 있는 데이터
            private int hp;
            private float speed;

            public void MoseMonster()
            {
                // 게임 엔진

                // 1. 플레이어를 찾는다.

                // 2. 그 방향을 방향을 구한다.

                // 3. 주어진 방향과 속도로 이동한다.

                Console.WriteLine($"몬스터의 속도 {speed}만큼 움직였다.");
            }
        }
        #region 은닉화
        // 은닉화 : 접근지정자
        // 접근지정자란 내부 데이터, 내부 연산을 외부에서 접근하지 못하게 제한하는 지정자
        // private, public, protected, internal, internal protected, internal private
        // 제한하는 것도 하나의 기능이라고 설명을 햇습니다.
        // 첫번째로 프로그램을 사용하는 소비자에게 보여지는 내용을 숨김으로써 프로그램에 사용에 용이성을 준다.
        // 두번째로 프로그램을 제작하는 프로그래머가 본인이 옛날 코드를 작성할 때나, 다른 사람과 함께 코드를 작성할 때
        // 이 코드는 변경하지 말라고 의사소통을 하지 않아도 접근 지정자를 보고 유추를 할 수 있습니다. 
        #endregion

        // 데이터를 보관하기 위한 목적인 클래스 Entity
        // 데이터를 사용하기 위한 목적인 클래스 Handler

        // 포유류에 강아지, 고양이, 돌고래,  3개다 각각 구현을 했다.

        #region 캡슐화
        // 캡슐화
        // 실제로 구현되는 부분을 외부에 드러나지 않도록 캡슐로 감싸서 숨기지만, 이용방법만 알려주는 것
        // 은닉화의 차이점
        // 은닉화는 숨기고 싶은 데이터를 원천적으로 막는 기능
        // 캡슐화는 숨기고 싶은 데이터는 숨기지만 외부와의 소통은 가능한 것 ( 불필요한 정보만 감춘다) 
        #endregion

        // -> 프로퍼티

        // 상속성
        // 클래스가 기반 클래스로 부터 데이터를 받아서 사용할 수 있게 기능을 제공해주었다.
        // 기반(base) 클래스에서 상속을 받은 클래스를 파생(derived) 클래스라고 부른다.
        // 상속을 하는 이유? : 코드의 재사용을 가능하게 해주어 불필요한 코드를 줄일 수 있다.
        // 상속을 받은 파생 클래스는(하위 클래스) 상위 클래스의 필드와 메서드를 자유롭게 사용할 수 있으며
        // 자신만의 데이터로 새로운 클래스로 확장이 가능하다.

        // 다형성
        // polymorphism 클래스가 다양한 형태를 가질 수 있다.
        // 포유류, 강아지, 고양이, 돌고래...   
        // 포유류만 선언을 해서 강아지, 고양이, 자신을 상속하는 모든 하위 클래스를 표현할 수 있습니다.
        // 오버라이딩, 오버로딩을 사용해서 코드를 확장해서 사용할 수 있다.
    }
}
